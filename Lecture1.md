# OCaml

## Main features

* No parathesis
* No indentation
* A statically typed language: typing is statically checked; types are inferred;
* A functional language
* Other features
	* references
	* Garbage collection
	* Other traits: records, arrays, modules, generalized algebraic data types.
  1 #!/usr/bin/env utop
  2 print_string "hello world!\n";;


# Proof-as-program correspondence 

Curry and Howard
which states that 

> A type is the same as a formula

> A program is the same as proof

## Arrow as implication

Given types T and U, the type T -> U

* the type of functions from T to U
* the type of programs which transform a T into a U
* the type of programs thanks to which having a T implies having a U
* the formula T => U
* the type of proofs of T => U

We can thus think of a program of type `'a -> 'a` as a proof of `A=>A`.
It can be proved by:

`let id = fun x -> x;;`

The formula `A=>B=>A`, i.e. the type `'a -> 'b -> 'a` can be proved by

`let k = fun x y -> x`

The formula `(A => B) => (B => C) => (A => C)`, 
i.e. the type `('a -> 'b) -> ('b -> 'c) -> 'a -> 'c`
can be proved by

`let comp f g x = g (f x)`

To understand: 
Take 'a as x,
take ('a -> 'b) as function f,
take ('b -> 'c) as function g.
the 'b of g comes from f, then we have
*g(f x)*.

**Theorem**: A formula can be proved(for a suitable notion of provability), if and only if there is a program of the corresponding type(for a suitable subset of OCaml).

In other words, PROGRAM = PROOF.

## Conjunction

The formula A$\and$Bcan be interpreted as the type `'a*'b`.
The (A$\and$B) => A correspongding to the type ('a * 'b) -> 'a,
It can be proved by

`let proj1 = fun (x,y) -> x`


## TRUTH

The truth formula `T`
can be interpreted as the type `unit`
whose only value is `()`

The formula `A => T`
corresponding to the type `'a -> ()`
canf be proved by

`fun x -> ()`

## Falsity

The falsity formula `\bot`
can be interpreted as the type `type empty = |` 
which is a recursive type with no constructor.

The formula `\bot => A`
corresponding to the type `empty -> 'a`
can be proved by 

`let absurd = fun x -> match x with _ -> .`


## Negation

As usual, negation can be defined as `$\neg$ = A => $\bot$`
which corresponds to the type `'a -> empty`

The contra postion formula `(A => B) => (\neg B => \neg A)`
correspongding to the type `('a -> 'b) -> ('b -> empty) -> 'a -> empty`
can be proved by

`let contr = fun f b' a -> b' (f a)`


## The disjunction 

/*TODO*/








# Typing Programming is safe

A simple programming language:

a program is a term generated by 

`
p,q :: = b
	| n
	| p + q
	| p < q
	| if b then p else q;;
`

A value is a program which is either a boolean b or an integer n.


`$\vdash p : A$`


* typing rules

* derivation tree

## Reduction

p ------> q

## Irreducible programs

* 3 + true
* if 5 then p else q
* ...

## Safety: subject reduction

**Theorem(Safety):** Given a program p of type A, either
					* there is an infinite sequence of reductions: p -> p1 -> p2 -> ...
					* or the reduction ends on a value: p -> p1 -> .. -> pn = v

























































